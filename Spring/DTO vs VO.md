## 혼용 사례
DTO(VO), DAO 혼용해서 쓰는 이유

이는 사실 J2EE Patterns 1판 초판에서는 데이터 전달용 객체를 VO로 정의 했는데
2판에서는 데이터 전달용 객체를 TO로 정의 했습니다.
VO- > TO 
현재는 D를 붙여 DTO라고 부릅니다.

DTO 데이터 전달용
VO 값 표현용 

DTO란 DAta Transfer Object 데이터를 전달하기 위해 사용하는객체 데이터를 담아서 전달하는 바구니 역활
계층간 데이터를 전달하기 위한 객체

흔히 Controller 레이어에서 Service레이어로 데이터를 전달할 때 Dto에 데이터를 실어 전달하는 역활을 하는게 DTO
오직 Getter/Setter 메서드 만을 갖는다 
다른 로직을 갖지 않는다.
순수하게 데이터 전달용 객체 이기 때문이다.
하지만 DTO에서 setter를 사용하게 되면 불변객체가 아니게 되므로
setter를 사용하면 가변
최대한 setter를 배제하며 불변객체로 만들어보자 setter를 사용하지 않는 필드는 final로 지정하고
getter/ setter 외에 로직을 사용하지 않음
DTO는 속성값이 모두 같다고 해서 같은 객체가 아니다.

그리고 우리가 오해하면 안되는 것이 Entity class가 있고 dto class가 있는데 entity class는 절대로 요청이나 응답 값을 전달하는 클래스로 사용되면 안됩니다.
왜냐하면 Entity class를 기준으로 스키마가 생성되고 테이블이 생성됩니다.
view는 비즈니스 로직에서 자주 변경되는 상황이 많은데 예를 들어 요청만 봐도
Entity클래스로 요청을 받는다고 하면 view에서는 레이아웃이 바뀌는 경우가 많은데 그러면 이럴 때 마다 entity를 구조가 바뀌는 문제가 발생한다.
이러한 문제 때문에
view에 변경에 따라 다른 클래스에 영향을 주지 않고 사용할 수 있는 Dto를 사용해야한다.
꼭 분리 해서 사용

VO
Value Object
값 그자체를 표현하는 객체
흔히 돈에서 만원 짜리 지페에 고유번호가 존재합니다.
하지마 저희는 이것은 다른 만원이야 라고 말하지 않습니다.
같은 만원이라고 표현하죠 
Value Object 또한 불변객체여야 한다.
setter 과 같은 메서드를 사용하면 안됌
무조건 생성자로 초기화 해야함
속성값이 모두 같으면 같은 객체이다.

Dto는 getter/ setter 로직을 가지고 있을 수 있지만 VO는 getter 외에 로직을 가질 수 있다. 뭐 금액을 더하는 함수라던지 
![[Pasted image 20231113194737.png]]
## N + 1 문제란?
ORM 기술에서 특정 객체를 대상으로 수행한 쿼리가 해당 객체가 가지고 있는 연관 관계또한 조회하게 되면서 N번의 추가적인 쿼리가 발생하는 문제를 말한다.
### 원인
N + 1 문제가 발생하는 근복적인 원인은 관계형 데이터베이스와 객체지향 언어간의 패러다임 불일치 문제이다.
객체지향에서는 연관관계를 통해 레퍼런스를 가지고 있다면 언제든지 메모리 내에서 Random Access를 통해 연관 객체에 접근할 수 있지만, 데이터베이스는 select를 통해 접근하여야 한다.


Entity 설정
* 고양이 집사는 여러 마리의 고양이를 키우고 있다
* 고양이는 한 명의 집사에 종속되어 있다.
```kotlin
	@Entity
	class Owner(
		@Id
		@GeneratedValue(strategy = GenerationType.IDENTITY)
		val id: Long,
		val name: String,
		@OneToMany(mappedBy = "owner", fetch = FetchType.EAGER)
		val cats: Set<Cat> = emptySet()
	) { 
		
	}

	@Entity
	class Cat(
		@Id
		@GeneratedValue(strategy = GenerationType.IDENTITY)
		val id: Long,
		val name: String,
		@ManyToOne
		val owner: Owner
	) {
	}
```
### 고양이 집사를 조회해보자
테스트 케이스를 작성하여 Mock데이터를 넣은 후에 조회를 하였다. 테스트 시나리오는 이렇다.
* 고양이를 10마리 생성하였다
* 고양이 집사를 10명 생성하였다.
* 고양이 집사는 10마리씩 고양이를 키우고 있다.
* 고양이 집사를 조회해보자. ( 확실한 결과를 도출하기 위해 entityManager를 한번 초기화 하였다. )

결론 한 명의 집사는 10마리의 고양이를 가지고 있다.
```kotlin
	@Test
	fun exampleTest() {
		val cats = emptySet()
		for(i in 0..10) {
			cats.add(Cat("cat ${i}")) // cat 1, cat 2, cat 3 ...
		}
		catRepository.saveAll(cats)

		val owners = arrayList<Owner>()
		for(i in 0..10) {
			val owner = Owner("owner ${i}")
			owner.cats(cats)
			owners.add(owner)
		}
		ownerRepository.saveAll(owners)

		entityManager.clear()

		println("==================================================")
		val everyOwners = ownerRepository.findAll()
		assertFalse(everyOwners.isEmpty)
	}
```
### 결과는 어떻게 되었을까?
Hibernate SQL log를 활성화하여 실제로 호출된 쿼리를 확인해 보았다. 확인된 쿼리는 아래와 같다.
* 고양이 집사 조회하는 쿼리를 호출
* 고양이를 조회하는 쿼리가 고양이 집사를 조회한 row 만큼 쿼리가 호출 한 것을 확인 할 수 있다.![[Pasted image 20231113201304.png]]
  
### 그렇다면 FetchType.EAGER이라서 발생한 것은 아닌가?
아니다. 간혹 즉시로딩이라서 이러한 문제가 생긴거라고 할 수 있지만 FetchType을 Lazy로 바꿔서 확인해보자
![[Pasted image 20231113201416.png]]
오 머야 쿼리가 하나 밖에 안나갔는데 해결된거 아니야 라고 할 수 있지만
그렇지 않다. FetchType을 LAZY로 설정했다는 것은 연관관계 데이터를 프록시 객체로 바인딩한다는 것이다. 하지만 실제로 우리는 연관관계 엔티티를 프록시만으로는 사용하지 않는다. 
아래와 같은 일로 쓰인다.
* 연관관계 엔티티의 멤버 변수 사용
* 연관관계 엔티티의 멤버 변수 가공 하는 코드 작성 및 구현
테스트 코드에서 연관관계 엔티티를 사용하는 로직을 추가해보자
* 고양이 집사가 보유하고 있는 고양이의 이름을 추출해보자
```kotlin
val everyOwners = ownerRepository.findAll()
val catNames = everyOwners.stream()
.flatMap {it -> it.cats.stream()
.map {cat -> cat.name}}
.toList()
assertFalse(catNames.isEmpty
```
### SQL 로그를 확인해보자
로그를 확인해보면 결국은 동일하게 문제가 발생하는 것을 알 수 있다. FetchType을 변경하는 것은 단지 N + 1이라는 문제의 발생 시점을 연관 관계 데이터를 사용하는 시점으로 미룰 것인지 초기 데이터를 로딩 하는 시점에서 가져올 때 일어날 것인지 차이 뿐이다.
![[Pasted image 20231113201917.png]]

### 그렇다면 N + 1은 왜 발생하는 것 일까?
JpaRepository에 정의한 인터페이스 메서드를 실행하면 JPA는 메서드 이름을 분석해서 JPQL을 생성하여 실행해준다. ( findAll() == select * from owner [ JPQL 이 메서드 이름을 분석해서 만들어준다 ] )
그렇기 때문에 JPQL은 findAll()이란 메소드를 수행하였을 때 해당 엔티티를 조회하는 select * from Owner 쿼리만 실행하게 되는 것이다. 
> [!tip]
> JPQL은 SQL을 추상화한 객체지향 쿼리 언어로서 특정 SQL에 종속되지 않고 엔티티 객체와 필드 이름을 가지고 쿼리를 한다.
> 
> **JPA에서 JPQL 동작원리**
> JPQL 입장에서는 연관관계 데이터를 무시하고 해당 엔티티 기준으로 쿼리를 조회하기 때문이다. 그렇기 때문에 연관된 엔티티 데이터가 필요한 경우, FetchType으로 지정한 시점에 조회를 별도로 호출하게 된다.

### 해결방안이 무엇이 있을까?
'Fetch Join'
사실 우리가 원하는 코드는 **select * from owner left join cat on cat.owner_id = owner.id** 일것이다.
최적화된 쿼리를 우리가 직접 사용할 수 있다. Fetch Join을 사용하는 것이다. 하지만 이는 JPARepository에서 제공하는 것이 아닌 JPQL에서 제공하는 것이다.



**N + 1 문제란?**
연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수(n) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오는 현상


현재 Entity는
즉시로딩으로 구현되어 있다.
```kotlin
@Entity  
class Team(  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    val id: Long,  
    val name: String,  
    @OneToMany(fetch = FetchType.EAGER)  
    val users: List<User> = arrayListOf()  
) {  
}
```
```kotlin
@Entity  
class User(  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    val id: Long,  
    val firstName: String,  
    val lastName: String,  
    @ManyToOne(fetch = FetchType.EAGER)  
    @JoinColumn(name = "team_id", nullable = false)  
    val team: Team  
) {  
}
```
아래는 테스트 코드
```kotlin
@Test  
fun N_plus_1_문제_테스트() {  
    val team = Team(0, name = "홍팀")  
    teamRepository.save(team)  // insert 쿼리 주인
    val users = generatedUserWithTeamForCount20(team)  
  
    teamRepository.findAll()   // select 쿼리 1개 select join, left join 쿼리 1개
    println("============= N + 1 시점 확인용 ======================")  
    assert(true).equals(true)  
}  
  
fun generatedUserWithTeamForCount20(team: Team) {  
    userRepository.save(User(0, "a", "b", team))  // insert 쿼리
}
```
일단 여기에서 분석 을 해보자 
insert 쿼리 2개
select 쿼리 1개
select join, left join 쿼리 1개
```kotlin
Hibernate: 
    insert 
    into
        team
        (name) 
    values
        (?)
Hibernate: 
    insert 
    into
        user
        (first_name,last_name,team_id) 
    values
        (?,?,?)
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        team t1_0
Hibernate: 
    select
        u1_0.team_id,
        u1_1.id,
        u1_1.first_name,
        u1_1.last_name,
        u1_1.team_id,
        t1_0.id,
        t1_0.name 
    from
        team_users u1_0 
    join
        user u1_1 
            on u1_1.id=u1_0.users_id 
    left join
        team t1_0 
            on t1_0.id=u1_1.team_id 
    where
        u1_0.team_id=?
============= N + 1 시점 확인용 ======================
```
teamRepository를 findAll 했기 때문에 실상 join 한번으로 가능하게 할 수 있다.
```kotlin
select
        t1_0.id,
        t1_0.name,
        u1_1.id,
        u1_1.first_name,
        u1_1.last_name,
        u1_1.team_id,
    from
        team t1_0

    from
        team_users u1_0 
    join
        user u1_1 
            on u1_1.id=u1_0.users_id 
    left join
        team t1_0 
            on t1_0.id=u1_1.team_id 
    where
        u1_0.team_id=?
```
하나의 스레드가 매 요청마다 EntityManagerFactory에서 EntityManager(영속성 컨텍스트)를 가져와 사용한다.
이렇게 된다면 하나의 스레드 마다 영속성 컨텍스트가 생기게 되는 것이다.

영속성 컨텍스트 내부에는 1차 캐시가 존재한다.
1차 캐시는 데이터 매커니즘을 개선하며 DB조회를 최소한으로 줄여 줄 수 있는 기법이다.

동작원리를 설명하기 전에 트랜잭션 범위에서 1차 캐시는 생명주기를 가지고 있기 때문에 트랜잭션이 commit 되어 flush 후 -> commit이 되어지면 영속성 컨텍스트에 있는 1차 캐시에 대한 데이터들은 생명을 끝나게 된다.

이제 설명하겠다.
조회 시점 :
첫번째로 find()를 함수에 인자 로 기본키를 넣어 기본키 값으로 1차 캐시에 데이터를 먼저 조회한다. -> 하지만 데이터가 존재하지 않는다면 DB에 데이터를 조회해서 가져온 후 1차 캐시에 데이터를 저장하고 1차 캐시에 저장한 데이터를 반환한다.

저장 시점:
첫번째로 저장하려는 entity를 영속화 시킨 후 
```kotlin
em.persist(member) // 영속화 시킨 후
```
1차 캐시에 저장 하고, 논리적으로 쓰기 지연 SQL 저장소 라는 곳에 INSERT 쿼리를 생성해 쌓아 놓고 DB에 바로 넣지 않고 기다리는 상태를 만든다. 추 후 flush가 발생 할 때 쓰기 지연 저장소에 있는 SQL를 DB와 싱크를 맞춘다.


> [!tip]
>- `flush()` 는 1차캐시를 지우지는 않는다. 쿼리들을 DB에 날려서 DB와 싱크를 맞추는 역할을 한다.
> 또한 tx.commit()을 진행하기 전에 flush() 후 -> commit 되어진다.


근데 여기에서 동작 구조에서 Durty Checking 이라는 개념이 영속성 컨텍스트에서 이루어 진다.
Durty Checking은 말 그대로 데이터 베이스와 영속성 컨텍스트 데이터를 일치하게 만드는 방법인데
사실 DB에서 1차 캐시 조회하고 나서 Key Value 로 Key에는 기본키 Value에는 Entity 속성들이 들어가 저장되는데 하나 가 더 존재한다 처음 조회 한 Entity에 대한 스냅샷을 따서 저장한다. 이를 한 트랜잭션 내에ㅇ서 그 해당하는 기본키 Entity가 변경 될 때 현재 Entity와 스냅샷을 비교하여 다르다면 변경 update 문 쿼리를 쓰기 지연 SQL 문에 저장해놓고 나중에 flush 가 동작할 때 쓰기 지연 SQL 쿼리를 DB에 반영하여 DB와 애플리케이션 단에서 가지고 있는 정보를 일치화 시킨다.


이제 2차 캐시에 대해서 설명을 할 건데.
2차 캐시는 애플리케이션 영역에서 위치 하고 있고, 공유 캐시 라고 애플리케이션이 종료되는 시점까지 생명주기가 살아 있는 캐시 이다

2차 캐시는 전체 공유 캐시이다 보니 하나의 객체를 다른 스레드에서 쓸 수 도 있어 동시성 문제를 예방하기 위해
객체를 복사본으로 반환하는 방식을 채택 하였습니다.

동작 원리는
1차 캐시에서 Entity를 찾아보고 없으면 2차 캐시에서 Entity를 찾는다.
찾는 엔티티가 존재하면 2차 캐시에서 반환하고 존재하지 않으면 DB를 조회해서 반환한다.